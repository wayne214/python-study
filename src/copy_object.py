import copy
# 常见的浅拷贝，就是使用数据类型本身的构造函数
# 浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。
# 因此，如果原对象中的元素不可变，那倒无所谓；
# 但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意。


l1 = [1,2,3]
l2 = list(l1)
l3 = copy.copy(l1) # copy函数
l4 = l1[:] # 使用切片操作符"："完成浅拷贝



print(l1 == l2)
print(l1 == l3)
print(l1 == l4)

print(l1 is l2)

ll1 = [[1, 2], (30, 40)]
ll2 = list(ll1)
# ll1.append(100)
# ll1[0].append(3)
#
# ll1[1] += (50, 60) # ll1第二个原生，拼接元组

print('----sss--', ll1 == ll2)
print('----sss--', ll1 is ll2)
print('----sss--', ll1, ll2)

print('----------------华丽丽的分割线--------------')

# 浅拷贝可能带来的副作用。因此，如果我们想避免这种副作用，完整地拷贝一个对象，你就得使用深度拷贝。

ll3 = copy.deepcopy(ll1)

print('---deep copy--ll3', ll3)


import copy
x = [1]
x.append(x)

x
[1, [...]]

y = copy.deepcopy(x)
y
[1, [...]]

# 列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。
# 但是我们发现深度拷贝 x 到 y 后，程序并没有出现 stack overflow 的现象。
# 这是为什么呢？其实，这是因为深度拷贝函数 deepcopy 中会维护一个字典，
# 记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回


# 比较操作符'=='表示比较对象间的值是否相等，而'is'表示比较对象的标识是否相等，即它们是否指向同一个内存地址。
# 比较操作符'is'效率优于'=='，因为'is'操作符无法被重载，执行'is'操作只是简单的获取对象的 ID，并进行比较；而'=='操作符则会递归地遍历对象的所有值，并逐一比较。
# 浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。
# 深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。

lll1 = [1, 2, 3]
lll2 = [1, 2, 3]
lll3 = lll2

print('--ddd--',id(lll1), id(lll2),lll1 is lll2, lll2 is lll3)


def func(d):
    d['a'] = 10
    d['b'] = 20

d = {'a': 1, 'b': 2}
func(d)
print(d)
